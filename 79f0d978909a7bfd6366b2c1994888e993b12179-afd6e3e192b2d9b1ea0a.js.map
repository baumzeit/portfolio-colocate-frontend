{"version":3,"file":"79f0d978909a7bfd6366b2c1994888e993b12179-afd6e3e192b2d9b1ea0a.js","mappings":"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","sources":["webpack://portfolio-colocate/./src/common/components/Main.tsx","webpack://portfolio-colocate/./src/common/components/Layout.tsx","webpack://portfolio-colocate/./src/common/utility/get-image.ts","webpack://portfolio-colocate/./src/common/utility/not-empty.ts","webpack://portfolio-colocate/./node_modules/jotai/esm/index.js"],"sourcesContent":["import React, { forwardRef, PropsWithChildren } from 'react'\nimport { twMerge } from 'tailwind-merge'\n\ntype MainProps = {\n  className?: string\n}\n\nexport const Main = forwardRef<HTMLDivElement, PropsWithChildren<MainProps>>(({ children, className = '' }, ref) => {\n  return (\n    <main className={twMerge('relative overflow-auto', className)} ref={ref}>\n      {children}\n    </main>\n  )\n})\n","import { Atom, Provider } from 'jotai'\nimport React, { forwardRef, ReactNode } from 'react'\n\nimport { Main } from './Main'\n\ntype LayoutProps = {\n  seo?: any\n  fullWidth?: boolean\n  navbar?: ReactNode\n  providerData?: Iterable<readonly [Atom<unknown>, unknown]> | undefined\n  children: ReactNode\n}\n\nconst Layout = forwardRef<HTMLDivElement, LayoutProps>(({ children, navbar, providerData }, ref) => {\n  return (\n    <Provider initialValues={providerData}>\n      <div className=\"grid h-screen bg-primary\" style={{ gridTemplateRows: `auto 1fr` }}>\n        {/* <Seo seo={seo} /> */}\n        {navbar}\n        <Main ref={ref}>{children}</Main>\n      </div>\n    </Provider>\n  )\n})\n\nexport default Layout\n","import { IGatsbyImageData } from 'gatsby-plugin-image'\n\ntype DeepMaybe<T> = T extends object\n  ? {\n      [P in keyof T]?: P extends 'gatsbyImageData' ? IGatsbyImageData : DeepMaybe<T[P]> | null\n    }\n  : T\n\ntype StrapiMedia = DeepMaybe<Queries.STRAPI__MEDIA> | null\n\nexport const getStrapiImage = <T extends StrapiMedia = StrapiMedia>(queryImage: T) =>\n  queryImage?.localFile?.childImageSharp?.gatsbyImageData\n","function notEmpty<TValue>(value: TValue | null | undefined): value is TValue {\n  if (value === null || value === undefined) return false\n  return true\n}\n\nexport default notEmpty\n","import { createContext, useState, useEffect, useRef, createElement, useContext, useReducer, useDebugValue, useCallback } from 'react';\n\nconst SUSPENSE_PROMISE = Symbol();\nconst isSuspensePromise = (promise) => !!promise[SUSPENSE_PROMISE];\nconst isSuspensePromiseAlreadyCancelled = (suspensePromise) => !suspensePromise[SUSPENSE_PROMISE].c;\nconst cancelSuspensePromise = (suspensePromise) => {\n  var _a, _b;\n  (_b = (_a = suspensePromise[SUSPENSE_PROMISE]).c) == null ? void 0 : _b.call(_a);\n};\nconst isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {\n  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\nconst createSuspensePromise = (promise) => {\n  const objectToAttach = {\n    o: promise,\n    c: null\n  };\n  const suspensePromise = new Promise((resolve) => {\n    objectToAttach.c = () => {\n      objectToAttach.c = null;\n      resolve();\n    };\n    promise.then(objectToAttach.c, objectToAttach.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = objectToAttach;\n  return suspensePromise;\n};\n\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst READ_ATOM = \"r\";\nconst WRITE_ATOM = \"w\";\nconst COMMIT_ATOM = \"c\";\nconst SUBSCRIBE_ATOM = \"s\";\nconst RESTORE_ATOMS = \"h\";\nconst DEV_SUBSCRIBE_STATE = \"n\";\nconst DEV_GET_MOUNTED_ATOMS = \"l\";\nconst DEV_GET_ATOM_STATE = \"a\";\nconst DEV_GET_MOUNTED = \"m\";\nconst createStore = (initialValues) => {\n  const committedAtomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  if (initialValues) {\n    for (const [atom, value] of initialValues) {\n      const atomState = { v: value, r: 0, d: /* @__PURE__ */ new Map() };\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        Object.freeze(atomState);\n        if (!hasInitialValue(atom)) {\n          console.warn(\n            \"Found initial value for derived atom which can cause unexpected behavior\",\n            atom\n          );\n        }\n      }\n      committedAtomStateMap.set(atom, atomState);\n    }\n  }\n  const suspensePromiseCacheMap = /* @__PURE__ */ new WeakMap();\n  const addSuspensePromiseToCache = (version, atom, suspensePromise) => {\n    let cache = suspensePromiseCacheMap.get(atom);\n    if (!cache) {\n      cache = /* @__PURE__ */ new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n    suspensePromise.then(() => {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n  const cancelAllSuspensePromiseInCache = (atom) => {\n    const versionSet = /* @__PURE__ */ new Set();\n    const cache = suspensePromiseCacheMap.get(atom);\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach((suspensePromise, version) => {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n    return versionSet;\n  };\n  const versionedAtomStateMapMap = /* @__PURE__ */ new WeakMap();\n  const getVersionedAtomStateMap = (version) => {\n    let versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = /* @__PURE__ */ new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n    return versionedAtomStateMap;\n  };\n  const getAtomState = (version, atom) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      let atomState = versionedAtomStateMap.get(atom);\n      if (!atomState) {\n        atomState = getAtomState(version.p, atom);\n        if (atomState) {\n          versionedAtomStateMap.set(atom, atomState);\n        }\n      }\n      return atomState;\n    }\n    return committedAtomStateMap.get(atom);\n  };\n  const setAtomState = (version, atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n  const createReadDependencies = (version, prevReadDependencies = /* @__PURE__ */ new Map(), dependencies) => {\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n    const readDependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    dependencies.forEach((atom) => {\n      var _a;\n      const revision = ((_a = getAtomState(version, atom)) == null ? void 0 : _a.r) || 0;\n      readDependencies.set(atom, revision);\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n    return readDependencies;\n  };\n  const setAtomValue = (version, atom, value, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    let changed = false;\n    if (!atomState || !(\"v\" in atomState) || !Object.is(atomState.v, value)) {\n      changed = true;\n      ++nextAtomState.r;\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    } else if (\"i\" in atomState || nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every((a) => atomState.d.has(a)))) {\n      changed = true;\n      Promise.resolve().then(() => {\n        flushPending(version);\n      });\n    }\n    if (atomState && !changed) {\n      return atomState;\n    }\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomReadError = (version, atom, error, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      e: error,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomSuspensePromise = (version, atom, suspensePromise, dependencies) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState && \"p\" in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise)) {\n        return atomState;\n      }\n      cancelSuspensePromise(atomState.p);\n    }\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    const nextAtomState = {\n      p: suspensePromise,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomPromiseOrValue = (version, atom, promiseOrValue, dependencies) => {\n    if (promiseOrValue instanceof Promise) {\n      const suspensePromise = createSuspensePromise(\n        promiseOrValue.then((value) => {\n          setAtomValue(version, atom, value, dependencies, suspensePromise);\n        }).catch((e) => {\n          if (e instanceof Promise) {\n            if (isSuspensePromise(e)) {\n              return e.then(() => {\n                readAtomState(version, atom, true);\n              });\n            }\n            return e;\n          }\n          setAtomReadError(version, atom, e, dependencies, suspensePromise);\n        })\n      );\n      return setAtomSuspensePromise(\n        version,\n        atom,\n        suspensePromise,\n        dependencies\n      );\n    }\n    return setAtomValue(\n      version,\n      atom,\n      promiseOrValue,\n      dependencies\n    );\n  };\n  const setAtomInvalidated = (version, atom) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      const nextAtomState = {\n        ...atomState,\n        i: atomState.r\n      };\n      setAtomState(version, atom, nextAtomState);\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not invalidate non existing atom\", atom);\n    }\n  };\n  const readAtomState = (version, atom, force) => {\n    if (!force) {\n      const atomState = getAtomState(version, atom);\n      if (atomState) {\n        if (atomState.r !== atomState.i && \"p\" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          return atomState;\n        }\n        atomState.d.forEach((_, a) => {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              const aState = getAtomState(version, a);\n              if (aState && aState.r === aState.i) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n        if (Array.from(atomState.d).every(([a, r]) => {\n          const aState = getAtomState(version, a);\n          return aState && \"v\" in aState && aState.r === r;\n        })) {\n          return atomState;\n        }\n      }\n    }\n    const dependencies = /* @__PURE__ */ new Set();\n    try {\n      const promiseOrValue = atom.read((a) => {\n        dependencies.add(a);\n        const aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n        if (aState) {\n          if (\"e\" in aState) {\n            throw aState.e;\n          }\n          if (\"p\" in aState) {\n            throw aState.p;\n          }\n          return aState.v;\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        const suspensePromise = createSuspensePromise(errorOrPromise);\n        return setAtomSuspensePromise(\n          version,\n          atom,\n          suspensePromise,\n          dependencies\n        );\n      }\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n  const readAtom = (readingAtom, version) => {\n    const atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n  const addAtom = (version, addingAtom) => {\n    let mounted = mountedMap.get(addingAtom);\n    if (!mounted) {\n      mounted = mountAtom(version, addingAtom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (version, deletingAtom) => {\n    const mounted = mountedMap.get(deletingAtom);\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(version, deletingAtom);\n    }\n  };\n  const invalidateDependents = (version, atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n  const writeAtomState = (version, atom, update) => {\n    let isSync = true;\n    const writeGetter = (a, options) => {\n      const aState = readAtomState(version, a);\n      if (\"e\" in aState) {\n        throw aState.e;\n      }\n      if (\"p\" in aState) {\n        if (options == null ? void 0 : options.unstable_promise) {\n          return aState.p.then(\n            () => writeGetter(a, options)\n          );\n        }\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.info(\n            \"Reading pending atom state in write operation. We throw a promise for now.\",\n            a\n          );\n        }\n        throw aState.p;\n      }\n      if (\"v\" in aState) {\n        return aState.v;\n      }\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\n          \"[Bug] no value found while reading atom in write operation. This is probably a bug.\",\n          a\n        );\n      }\n      throw new Error(\"no value found\");\n    };\n    const setter = (a, v) => {\n      let promiseOrVoid2;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach((cancelledVersion) => {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        const prevAtomState = getAtomState(version, a);\n        const nextAtomState = setAtomPromiseOrValue(version, a, v);\n        if (prevAtomState !== nextAtomState) {\n          invalidateDependents(version, a);\n        }\n      } else {\n        promiseOrVoid2 = writeAtomState(version, a, v);\n      }\n      if (!isSync) {\n        flushPending(version);\n      }\n      return promiseOrVoid2;\n    };\n    const promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    return promiseOrVoid;\n  };\n  const writeAtom = (writingAtom, update, version) => {\n    const promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n  const isActuallyWritableAtom = (atom) => !!atom.write;\n  const mountAtom = (version, atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    const atomState = readAtomState(void 0, atom);\n    atomState.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(version, a, atom);\n        }\n      }\n    });\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const setAtom = (update) => writeAtom(atom, update, version);\n      const onUnmount = atom.onMount(setAtom);\n      version = void 0;\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (version, atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(version, a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (version, atom, atomState, prevReadDependencies) => {\n    const dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_, a) => {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(version, a);\n        }\n      }\n    });\n    dependencies.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(version, a, atom);\n      }\n    });\n  };\n  const flushPending = (version) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach((atomState, atom) => {\n        const committedAtomState = committedAtomStateMap.get(atom);\n        if (atomState !== committedAtomState) {\n          const mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach((listener) => listener(version));\n        }\n      });\n      return;\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(void 0, atom);\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(void 0, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (prevAtomState && \"i\" in prevAtomState && atomState && !(\"i\" in atomState)) {\n          return;\n        }\n        const mounted = mountedMap.get(atom);\n        mounted == null ? void 0 : mounted.l.forEach((listener) => listener());\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach((l) => l());\n    }\n  };\n  const commitVersionedAtomStateMap = (version) => {\n    const versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach((atomState, atom) => {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      if (!prevAtomState || atomState.r > prevAtomState.r || \"v\" in atomState && atomState.r === prevAtomState.r && atomState.d !== prevAtomState.d) {\n        committedAtomStateMap.set(atom, atomState);\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(version, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n  const commitAtom = (_atom, version) => {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n    flushPending(void 0);\n  };\n  const subscribeAtom = (atom, callback, version) => {\n    const mounted = addAtom(version, atom);\n    const listeners = mounted.l;\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n      delAtom(version, atom);\n    };\n  };\n  const restoreAtoms = (values, version) => {\n    for (const [atom, value] of values) {\n      if (hasInitialValue(atom)) {\n        setAtomPromiseOrValue(version, atom, value);\n        invalidateDependents(version, atom);\n      }\n    }\n    flushPending(version);\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      [READ_ATOM]: readAtom,\n      [WRITE_ATOM]: writeAtom,\n      [COMMIT_ATOM]: commitAtom,\n      [SUBSCRIBE_ATOM]: subscribeAtom,\n      [RESTORE_ATOMS]: restoreAtoms,\n      [DEV_SUBSCRIBE_STATE]: (l) => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),\n      [DEV_GET_ATOM_STATE]: (a) => committedAtomStateMap.get(a),\n      [DEV_GET_MOUNTED]: (a) => mountedMap.get(a)\n    };\n  }\n  return {\n    [READ_ATOM]: readAtom,\n    [WRITE_ATOM]: writeAtom,\n    [COMMIT_ATOM]: commitAtom,\n    [SUBSCRIBE_ATOM]: subscribeAtom,\n    [RESTORE_ATOMS]: restoreAtoms\n  };\n};\nconst createStoreForExport = (initialValues) => {\n  const store = createStore(initialValues);\n  const get = (atom) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      return void 0;\n    }\n    return atomState.v;\n  };\n  const asyncGet = (atom) => new Promise((resolve, reject) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      reject(atomState.e);\n    } else if (\"p\" in atomState) {\n      resolve(atomState.p.then(() => asyncGet(atom)));\n    } else {\n      resolve(atomState.v);\n    }\n  });\n  const set = (atom, update) => store[WRITE_ATOM](atom, update);\n  const sub = (atom, callback) => store[SUBSCRIBE_ATOM](atom, callback);\n  return {\n    get,\n    asyncGet,\n    set,\n    sub,\n    SECRET_INTERNAL_store: store\n  };\n};\n\nconst createScopeContainer = (initialValues, unstable_createStore) => {\n  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);\n  return { s: store };\n};\nconst ScopeContextMap = /* @__PURE__ */ new Map();\nconst getScopeContext = (scope) => {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, createContext(createScopeContainer()));\n  }\n  return ScopeContextMap.get(scope);\n};\n\nconst Provider = ({\n  children,\n  initialValues,\n  scope,\n  unstable_createStore,\n  unstable_enableVersionedWrite\n}) => {\n  const [version, setVersion] = useState({});\n  useEffect(() => {\n    const scopeContainer = scopeContainerRef.current;\n    if (scopeContainer.w) {\n      scopeContainer.s[COMMIT_ATOM](null, version);\n      delete version.p;\n      scopeContainer.v = version;\n    }\n  }, [version]);\n  const scopeContainerRef = useRef();\n  if (!scopeContainerRef.current) {\n    const scopeContainer = createScopeContainer(\n      initialValues,\n      unstable_createStore\n    );\n    if (unstable_enableVersionedWrite) {\n      let retrying = 0;\n      scopeContainer.w = (write) => {\n        setVersion((parentVersion) => {\n          const nextVersion = retrying ? parentVersion : { p: parentVersion };\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n      scopeContainer.v = version;\n      scopeContainer.r = (fn) => {\n        ++retrying;\n        fn();\n        --retrying;\n      };\n    }\n    scopeContainerRef.current = scopeContainer;\n  }\n  const ScopeContainerContext = getScopeContext(scope);\n  return createElement(\n    ScopeContainerContext.Provider,\n    {\n      value: scopeContainerRef.current\n    },\n    children\n  );\n};\n\nlet keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = (get) => get(config);\n    config.write = (get, set, update) => set(config, typeof update === \"function\" ? update(get(config)) : update);\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\n\nfunction useAtomValue(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const scopeContainer = useContext(ScopeContext);\n  const { s: store, v: versionFromProvider } = scopeContainer;\n  const getAtomValue = (version2) => {\n    const atomState = store[READ_ATOM](atom, version2);\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      throw atomState.p;\n    }\n    if (\"v\" in atomState) {\n      return atomState.v;\n    }\n    throw new Error(\"no atom value\");\n  };\n  const [[version, valueFromReducer, atomFromReducer], rerenderIfChanged] = useReducer(\n    (prev, nextVersion) => {\n      const nextValue = getAtomValue(nextVersion);\n      if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n        return prev;\n      }\n      return [nextVersion, nextValue, atom];\n    },\n    versionFromProvider,\n    (initialVersion) => {\n      const initialValue = getAtomValue(initialVersion);\n      return [initialVersion, initialValue, atom];\n    }\n  );\n  let value = valueFromReducer;\n  if (atomFromReducer !== atom) {\n    rerenderIfChanged(version);\n    value = getAtomValue(version);\n  }\n  useEffect(() => {\n    const { v: versionFromProvider2 } = scopeContainer;\n    if (versionFromProvider2) {\n      store[COMMIT_ATOM](atom, versionFromProvider2);\n    }\n    const unsubscribe = store[SUBSCRIBE_ATOM](\n      atom,\n      rerenderIfChanged,\n      versionFromProvider2\n    );\n    rerenderIfChanged(versionFromProvider2);\n    return unsubscribe;\n  }, [store, atom, scopeContainer]);\n  useEffect(() => {\n    store[COMMIT_ATOM](atom, version);\n  });\n  useDebugValue(value);\n  return value;\n}\n\nfunction useSetAtom(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const { s: store, w: versionedWrite } = useContext(ScopeContext);\n  const setAtom = useCallback(\n    (update) => {\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      const write = (version) => store[WRITE_ATOM](atom, update, version);\n      return versionedWrite ? versionedWrite(write) : write();\n    },\n    [store, versionedWrite, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, scope) {\n  if (\"scope\" in atom) {\n    console.warn(\n      \"atom.scope is deprecated. Please do useAtom(atom, scope) instead.\"\n    );\n    scope = atom.scope;\n  }\n  return [\n    useAtomValue(atom, scope),\n    useSetAtom(atom, scope)\n  ];\n}\n\nexport { Provider, getScopeContext as SECRET_INTERNAL_getScopeContext, atom, createStoreForExport as unstable_createStore, useAtom, useAtomValue, useSetAtom };\n"],"names":["Main","forwardRef","ref","children","className","_ref","React","twMerge","navbar","providerData","Provider","initialValues","style","gridTemplateRows","getStrapiImage","queryImage","localFile","_queryImage$localFile","childImageSharp","_queryImage$localFile2","gatsbyImageData","value","SUSPENSE_PROMISE","Symbol","isSuspensePromise","promise","cancelSuspensePromise","suspensePromise","_a","_b","c","call","isEqualSuspensePromise","oldSuspensePromise","newSuspensePromise","oldOriginalPromise","o","newOriginalPromise","createSuspensePromise","objectToAttach","Promise","resolve","then","hasInitialValue","atom","READ_ATOM","WRITE_ATOM","COMMIT_ATOM","SUBSCRIBE_ATOM","createStore","committedAtomStateMap","WeakMap","mountedMap","pendingMap","Map","stateListeners","mountedAtoms","Set","atomState","v","r","d","Object","freeze","console","warn","set","suspensePromiseCacheMap","versionedAtomStateMapMap","getVersionedAtomStateMap","version","versionedAtomStateMap","get","getAtomState","p","setAtomState","prevAtomState","has","createReadDependencies","prevReadDependencies","dependencies","readDependencies","changed","forEach","revision","size","setAtomValue","nextAtomState","is","Array","from","keys","every","a","flushPending","setAtomReadError","error","e","setAtomSuspensePromise","cache","delete","addSuspensePromiseToCache","setAtomPromiseOrValue","promiseOrValue","catch","readAtomState","force","i","_","aState","read","add","init","Error","errorOrPromise","readAtom","readingAtom","canUnmountAtom","mounted","l","t","invalidateDependents","dependent","setAtomInvalidated","writeAtomState","update","isSync","writeGetter","options","unstable_promise","info","promiseOrVoid","write","promiseOrVoid2","versionSet","cancelAllSuspensePromiseInCache","cancelledVersion","writeAtom","writingAtom","mountAtom","initialDependent","aMounted","isActuallyWritableAtom","onMount","setAtom","onUnmount","u","unmountAtom","mountDependencies","listener","pending","clear","commitAtom","_atom","commitVersionedAtomStateMap","subscribeAtom","callback","addingAtom","addAtom","listeners","deletingAtom","delAtom","restoreAtoms","values","createScopeContainer","unstable_createStore","s","SECRET_INTERNAL_store","ScopeContextMap","getScopeContext","scope","createContext","unstable_enableVersionedWrite","setVersion","useState","useEffect","scopeContainer","scopeContainerRef","current","w","useRef","retrying","parentVersion","nextVersion","fn","ScopeContainerContext","createElement","keyCount","key","config","toString","useAtomValue","ScopeContext","useContext","store","versionFromProvider","getAtomValue","version2","valueFromReducer","atomFromReducer","rerenderIfChanged","useReducer","prev","nextValue","initialVersion","versionFromProvider2","unsubscribe","useDebugValue","useSetAtom","versionedWrite","useCallback","useAtom"],"sourceRoot":""}