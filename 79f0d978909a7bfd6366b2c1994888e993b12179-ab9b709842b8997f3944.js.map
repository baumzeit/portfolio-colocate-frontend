{"version":3,"file":"79f0d978909a7bfd6366b2c1994888e993b12179-ab9b709842b8997f3944.js","mappings":"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","sources":["webpack://portfolio-colocate/./node_modules/jotai/esm/index.js","webpack://portfolio-colocate/./src/common/components/Main.tsx","webpack://portfolio-colocate/./src/common/components/Layout.tsx","webpack://portfolio-colocate/./src/common/utility/not-empty.ts"],"sourcesContent":["import _defineProperty from \"/Users/baumzeit/Code/src/hobby/portfolio/portfolio-frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"/Users/baumzeit/Code/src/hobby/portfolio/portfolio-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { createContext, useState, useEffect, useRef, createElement, useContext, useReducer, useDebugValue, useCallback } from 'react';\nvar SUSPENSE_PROMISE = Symbol();\n\nvar isSuspensePromise = function isSuspensePromise(promise) {\n  return !!promise[SUSPENSE_PROMISE];\n};\n\nvar isSuspensePromiseAlreadyCancelled = function isSuspensePromiseAlreadyCancelled(suspensePromise) {\n  return !suspensePromise[SUSPENSE_PROMISE].c;\n};\n\nvar cancelSuspensePromise = function cancelSuspensePromise(suspensePromise) {\n  var _a, _b;\n\n  (_b = (_a = suspensePromise[SUSPENSE_PROMISE]).c) == null ? void 0 : _b.call(_a);\n};\n\nvar isEqualSuspensePromise = function isEqualSuspensePromise(oldSuspensePromise, newSuspensePromise) {\n  var oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  var newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\n\nvar createSuspensePromise = function createSuspensePromise(promise) {\n  var objectToAttach = {\n    o: promise,\n    c: null\n  };\n  var suspensePromise = new Promise(function (resolve) {\n    objectToAttach.c = function () {\n      objectToAttach.c = null;\n      resolve();\n    };\n\n    promise.then(objectToAttach.c, objectToAttach.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = objectToAttach;\n  return suspensePromise;\n};\n\nvar hasInitialValue = function hasInitialValue(atom) {\n  return \"init\" in atom;\n};\n\nvar READ_ATOM = \"r\";\nvar WRITE_ATOM = \"w\";\nvar COMMIT_ATOM = \"c\";\nvar SUBSCRIBE_ATOM = \"s\";\nvar RESTORE_ATOMS = \"h\";\nvar DEV_SUBSCRIBE_STATE = \"n\";\nvar DEV_GET_MOUNTED_ATOMS = \"l\";\nvar DEV_GET_ATOM_STATE = \"a\";\nvar DEV_GET_MOUNTED = \"m\";\n\nvar createStore = function createStore(initialValues) {\n  var _ref6;\n\n  var committedAtomStateMap = /* @__PURE__ */new WeakMap();\n  var mountedMap = /* @__PURE__ */new WeakMap();\n  var pendingMap = /* @__PURE__ */new Map();\n  var stateListeners;\n  var mountedAtoms;\n\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */new Set();\n    mountedAtoms = /* @__PURE__ */new Set();\n  }\n\n  if (initialValues) {\n    var _iterator = _createForOfIteratorHelper(initialValues),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n            _atom2 = _step$value[0],\n            value = _step$value[1];\n\n        var atomState = {\n          v: value,\n          r: 0,\n          d: /* @__PURE__ */new Map()\n        };\n\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          Object.freeze(atomState);\n\n          if (!hasInitialValue(_atom2)) {\n            console.warn(\"Found initial value for derived atom which can cause unexpected behavior\", _atom2);\n          }\n        }\n\n        committedAtomStateMap.set(_atom2, atomState);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  var suspensePromiseCacheMap = /* @__PURE__ */new WeakMap();\n\n  var addSuspensePromiseToCache = function addSuspensePromiseToCache(version, atom, suspensePromise) {\n    var cache = suspensePromiseCacheMap.get(atom);\n\n    if (!cache) {\n      cache = /* @__PURE__ */new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n\n    suspensePromise.then(function () {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n\n  var cancelAllSuspensePromiseInCache = function cancelAllSuspensePromiseInCache(atom) {\n    var versionSet = /* @__PURE__ */new Set();\n    var cache = suspensePromiseCacheMap.get(atom);\n\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach(function (suspensePromise, version) {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n\n    return versionSet;\n  };\n\n  var versionedAtomStateMapMap = /* @__PURE__ */new WeakMap();\n\n  var getVersionedAtomStateMap = function getVersionedAtomStateMap(version) {\n    var versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = /* @__PURE__ */new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n\n    return versionedAtomStateMap;\n  };\n\n  var getAtomState = function getAtomState(version, atom) {\n    if (version) {\n      var versionedAtomStateMap = getVersionedAtomStateMap(version);\n\n      var _atomState = versionedAtomStateMap.get(atom);\n\n      if (!_atomState) {\n        _atomState = getAtomState(version.p, atom);\n\n        if (_atomState) {\n          versionedAtomStateMap.set(atom, _atomState);\n        }\n      }\n\n      return _atomState;\n    }\n\n    return committedAtomStateMap.get(atom);\n  };\n\n  var setAtomState = function setAtomState(version, atom, atomState) {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n\n    if (version) {\n      var versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      var prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n\n  var createReadDependencies = function createReadDependencies(version) {\n    var prevReadDependencies = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /* @__PURE__ */new Map();\n    var dependencies = arguments.length > 2 ? arguments[2] : undefined;\n\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n\n    var readDependencies = /* @__PURE__ */new Map();\n    var changed = false;\n    dependencies.forEach(function (atom) {\n      var _a;\n\n      var revision = ((_a = getAtomState(version, atom)) == null ? void 0 : _a.r) || 0;\n      readDependencies.set(atom, revision);\n\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n\n    return readDependencies;\n  };\n\n  var setAtomValue = function setAtomValue(version, atom, value, dependencies, suspensePromise) {\n    var atomState = getAtomState(version, atom);\n\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n\n    var nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    var changed = false;\n\n    if (!atomState || !(\"v\" in atomState) || !Object.is(atomState.v, value)) {\n      changed = true;\n      ++nextAtomState.r;\n\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    } else if (\"i\" in atomState || nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every(function (a) {\n      return atomState.d.has(a);\n    }))) {\n      changed = true;\n      Promise.resolve().then(function () {\n        flushPending(version);\n      });\n    }\n\n    if (atomState && !changed) {\n      return atomState;\n    }\n\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n\n  var setAtomReadError = function setAtomReadError(version, atom, error, dependencies, suspensePromise) {\n    var atomState = getAtomState(version, atom);\n\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n\n    var nextAtomState = {\n      e: error,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n\n  var setAtomSuspensePromise = function setAtomSuspensePromise(version, atom, suspensePromise, dependencies) {\n    var atomState = getAtomState(version, atom);\n\n    if (atomState && \"p\" in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise)) {\n        return atomState;\n      }\n\n      cancelSuspensePromise(atomState.p);\n    }\n\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    var nextAtomState = {\n      p: suspensePromise,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n\n  var setAtomPromiseOrValue = function setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies) {\n    if (promiseOrValue instanceof Promise) {\n      var suspensePromise = createSuspensePromise(promiseOrValue.then(function (value) {\n        setAtomValue(version, atom, value, dependencies, suspensePromise);\n      }).catch(function (e) {\n        if (e instanceof Promise) {\n          if (isSuspensePromise(e)) {\n            return e.then(function () {\n              readAtomState(version, atom, true);\n            });\n          }\n\n          return e;\n        }\n\n        setAtomReadError(version, atom, e, dependencies, suspensePromise);\n      }));\n      return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n    }\n\n    return setAtomValue(version, atom, promiseOrValue, dependencies);\n  };\n\n  var setAtomInvalidated = function setAtomInvalidated(version, atom) {\n    var atomState = getAtomState(version, atom);\n\n    if (atomState) {\n      var nextAtomState = _objectSpread(_objectSpread({}, atomState), {}, {\n        i: atomState.r\n      });\n\n      setAtomState(version, atom, nextAtomState);\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not invalidate non existing atom\", atom);\n    }\n  };\n\n  var readAtomState = function readAtomState(version, atom, force) {\n    if (!force) {\n      var _atomState2 = getAtomState(version, atom);\n\n      if (_atomState2) {\n        if (_atomState2.r !== _atomState2.i && \"p\" in _atomState2 && !isSuspensePromiseAlreadyCancelled(_atomState2.p)) {\n          return _atomState2;\n        }\n\n        _atomState2.d.forEach(function (_, a) {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              var aState = getAtomState(version, a);\n\n              if (aState && aState.r === aState.i) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n\n        if (Array.from(_atomState2.d).every(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              a = _ref2[0],\n              r = _ref2[1];\n\n          var aState = getAtomState(version, a);\n          return aState && \"v\" in aState && aState.r === r;\n        })) {\n          return _atomState2;\n        }\n      }\n    }\n\n    var dependencies = /* @__PURE__ */new Set();\n\n    try {\n      var promiseOrValue = atom.read(function (a) {\n        dependencies.add(a);\n        var aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n\n        if (aState) {\n          if (\"e\" in aState) {\n            throw aState.e;\n          }\n\n          if (\"p\" in aState) {\n            throw aState.p;\n          }\n\n          return aState.v;\n        }\n\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n\n        throw new Error(\"no atom init\");\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        var suspensePromise = createSuspensePromise(errorOrPromise);\n        return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n      }\n\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n\n  var readAtom = function readAtom(readingAtom, version) {\n    var atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n\n  var addAtom = function addAtom(version, addingAtom) {\n    var mounted = mountedMap.get(addingAtom);\n\n    if (!mounted) {\n      mounted = mountAtom(version, addingAtom);\n    }\n\n    return mounted;\n  };\n\n  var canUnmountAtom = function canUnmountAtom(atom, mounted) {\n    return !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  };\n\n  var delAtom = function delAtom(version, deletingAtom) {\n    var mounted = mountedMap.get(deletingAtom);\n\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(version, deletingAtom);\n    }\n  };\n\n  var invalidateDependents = function invalidateDependents(version, atom) {\n    var mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach(function (dependent) {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n\n  var writeAtomState = function writeAtomState(version, atom, update) {\n    var isSync = true;\n\n    var writeGetter = function writeGetter(a, options) {\n      var aState = readAtomState(version, a);\n\n      if (\"e\" in aState) {\n        throw aState.e;\n      }\n\n      if (\"p\" in aState) {\n        if (options == null ? void 0 : options.unstable_promise) {\n          return aState.p.then(function () {\n            return writeGetter(a, options);\n          });\n        }\n\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.info(\"Reading pending atom state in write operation. We throw a promise for now.\", a);\n        }\n\n        throw aState.p;\n      }\n\n      if (\"v\" in aState) {\n        return aState.v;\n      }\n\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\"[Bug] no value found while reading atom in write operation. This is probably a bug.\", a);\n      }\n\n      throw new Error(\"no value found\");\n    };\n\n    var setter = function setter(a, v) {\n      var promiseOrVoid2;\n\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n\n        var versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach(function (cancelledVersion) {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        var prevAtomState = getAtomState(version, a);\n        var nextAtomState = setAtomPromiseOrValue(version, a, v);\n\n        if (prevAtomState !== nextAtomState) {\n          invalidateDependents(version, a);\n        }\n      } else {\n        promiseOrVoid2 = writeAtomState(version, a, v);\n      }\n\n      if (!isSync) {\n        flushPending(version);\n      }\n\n      return promiseOrVoid2;\n    };\n\n    var promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    return promiseOrVoid;\n  };\n\n  var writeAtom = function writeAtom(writingAtom, update, version) {\n    var promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n\n  var isActuallyWritableAtom = function isActuallyWritableAtom(atom) {\n    return !!atom.write;\n  };\n\n  var mountAtom = function mountAtom(version, atom, initialDependent) {\n    var mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */new Set()\n    };\n    mountedMap.set(atom, mounted);\n\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n\n    var atomState = readAtomState(void 0, atom);\n    atomState.d.forEach(function (_, a) {\n      var aMounted = mountedMap.get(a);\n\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(version, a, atom);\n        }\n      }\n    });\n\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      var setAtom = function setAtom(update) {\n        return writeAtom(atom, update, version);\n      };\n\n      var onUnmount = atom.onMount(setAtom);\n      version = void 0;\n\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n\n    return mounted;\n  };\n\n  var unmountAtom = function unmountAtom(version, atom) {\n    var _a;\n\n    var onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n\n    if (onUnmount) {\n      onUnmount();\n    }\n\n    mountedMap.delete(atom);\n\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n\n    var atomState = getAtomState(version, atom);\n\n    if (atomState) {\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom) {\n          var mounted = mountedMap.get(a);\n\n          if (mounted) {\n            mounted.t.delete(atom);\n\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(version, a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n\n  var mountDependencies = function mountDependencies(version, atom, atomState, prevReadDependencies) {\n    var dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach(function (_, a) {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n\n      var mounted = mountedMap.get(a);\n\n      if (mounted) {\n        mounted.t.delete(atom);\n\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(version, a);\n        }\n      }\n    });\n    dependencies.forEach(function (a) {\n      var mounted = mountedMap.get(a);\n\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(version, a, atom);\n      }\n    });\n  };\n\n  var flushPending = function flushPending(version) {\n    if (version) {\n      var versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach(function (atomState, atom) {\n        var committedAtomState = committedAtomStateMap.get(atom);\n\n        if (atomState !== committedAtomState) {\n          var mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach(function (listener) {\n            return listener(version);\n          });\n        }\n      });\n      return;\n    }\n\n    while (pendingMap.size) {\n      var pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            atom = _ref4[0],\n            prevAtomState = _ref4[1];\n\n        var atomState = getAtomState(void 0, atom);\n\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(void 0, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n\n        if (prevAtomState && \"i\" in prevAtomState && atomState && !(\"i\" in atomState)) {\n          return;\n        }\n\n        var mounted = mountedMap.get(atom);\n        mounted == null ? void 0 : mounted.l.forEach(function (listener) {\n          return listener();\n        });\n      });\n    }\n\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach(function (l) {\n        return l();\n      });\n    }\n  };\n\n  var commitVersionedAtomStateMap = function commitVersionedAtomStateMap(version) {\n    var versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach(function (atomState, atom) {\n      var prevAtomState = committedAtomStateMap.get(atom);\n\n      if (!prevAtomState || atomState.r > prevAtomState.r || \"v\" in atomState && atomState.r === prevAtomState.r && atomState.d !== prevAtomState.d) {\n        committedAtomStateMap.set(atom, atomState);\n\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(version, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n\n  var commitAtom = function commitAtom(_atom, version) {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n\n    flushPending(void 0);\n  };\n\n  var subscribeAtom = function subscribeAtom(atom, callback, version) {\n    var mounted = addAtom(version, atom);\n    var listeners = mounted.l;\n    listeners.add(callback);\n    return function () {\n      listeners.delete(callback);\n      delAtom(version, atom);\n    };\n  };\n\n  var restoreAtoms = function restoreAtoms(values, version) {\n    var _iterator2 = _createForOfIteratorHelper(values),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _slicedToArray(_step2.value, 2),\n            _atom3 = _step2$value[0],\n            _value = _step2$value[1];\n\n        if (hasInitialValue(_atom3)) {\n          setAtomPromiseOrValue(version, _atom3, _value);\n          invalidateDependents(version, _atom3);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    flushPending(version);\n  };\n\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    var _ref5;\n\n    return _ref5 = {}, _defineProperty(_ref5, READ_ATOM, readAtom), _defineProperty(_ref5, WRITE_ATOM, writeAtom), _defineProperty(_ref5, COMMIT_ATOM, commitAtom), _defineProperty(_ref5, SUBSCRIBE_ATOM, subscribeAtom), _defineProperty(_ref5, RESTORE_ATOMS, restoreAtoms), _defineProperty(_ref5, DEV_SUBSCRIBE_STATE, function (l) {\n      stateListeners.add(l);\n      return function () {\n        stateListeners.delete(l);\n      };\n    }), _defineProperty(_ref5, DEV_GET_MOUNTED_ATOMS, function () {\n      return mountedAtoms.values();\n    }), _defineProperty(_ref5, DEV_GET_ATOM_STATE, function (a) {\n      return committedAtomStateMap.get(a);\n    }), _defineProperty(_ref5, DEV_GET_MOUNTED, function (a) {\n      return mountedMap.get(a);\n    }), _ref5;\n  }\n\n  return _ref6 = {}, _defineProperty(_ref6, READ_ATOM, readAtom), _defineProperty(_ref6, WRITE_ATOM, writeAtom), _defineProperty(_ref6, COMMIT_ATOM, commitAtom), _defineProperty(_ref6, SUBSCRIBE_ATOM, subscribeAtom), _defineProperty(_ref6, RESTORE_ATOMS, restoreAtoms), _ref6;\n};\n\nvar createStoreForExport = function createStoreForExport(initialValues) {\n  var store = createStore(initialValues);\n\n  var get = function get(atom) {\n    var atomState = store[READ_ATOM](atom);\n\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n\n    if (\"p\" in atomState) {\n      return void 0;\n    }\n\n    return atomState.v;\n  };\n\n  var asyncGet = function asyncGet(atom) {\n    return new Promise(function (resolve, reject) {\n      var atomState = store[READ_ATOM](atom);\n\n      if (\"e\" in atomState) {\n        reject(atomState.e);\n      } else if (\"p\" in atomState) {\n        resolve(atomState.p.then(function () {\n          return asyncGet(atom);\n        }));\n      } else {\n        resolve(atomState.v);\n      }\n    });\n  };\n\n  var set = function set(atom, update) {\n    return store[WRITE_ATOM](atom, update);\n  };\n\n  var sub = function sub(atom, callback) {\n    return store[SUBSCRIBE_ATOM](atom, callback);\n  };\n\n  return {\n    get: get,\n    asyncGet: asyncGet,\n    set: set,\n    sub: sub,\n    SECRET_INTERNAL_store: store\n  };\n};\n\nvar createScopeContainer = function createScopeContainer(initialValues, unstable_createStore) {\n  var store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);\n  return {\n    s: store\n  };\n};\n\nvar ScopeContextMap = /* @__PURE__ */new Map();\n\nvar getScopeContext = function getScopeContext(scope) {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, createContext(createScopeContainer()));\n  }\n\n  return ScopeContextMap.get(scope);\n};\n\nvar Provider = function Provider(_ref7) {\n  var children = _ref7.children,\n      initialValues = _ref7.initialValues,\n      scope = _ref7.scope,\n      unstable_createStore = _ref7.unstable_createStore,\n      unstable_enableVersionedWrite = _ref7.unstable_enableVersionedWrite;\n\n  var _useState = useState({}),\n      _useState2 = _slicedToArray(_useState, 2),\n      version = _useState2[0],\n      setVersion = _useState2[1];\n\n  useEffect(function () {\n    var scopeContainer = scopeContainerRef.current;\n\n    if (scopeContainer.w) {\n      scopeContainer.s[COMMIT_ATOM](null, version);\n      delete version.p;\n      scopeContainer.v = version;\n    }\n  }, [version]);\n  var scopeContainerRef = useRef();\n\n  if (!scopeContainerRef.current) {\n    var scopeContainer = createScopeContainer(initialValues, unstable_createStore);\n\n    if (unstable_enableVersionedWrite) {\n      var retrying = 0;\n\n      scopeContainer.w = function (write) {\n        setVersion(function (parentVersion) {\n          var nextVersion = retrying ? parentVersion : {\n            p: parentVersion\n          };\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n\n      scopeContainer.v = version;\n\n      scopeContainer.r = function (fn) {\n        ++retrying;\n        fn();\n        --retrying;\n      };\n    }\n\n    scopeContainerRef.current = scopeContainer;\n  }\n\n  var ScopeContainerContext = getScopeContext(scope);\n  return createElement(ScopeContainerContext.Provider, {\n    value: scopeContainerRef.current\n  }, children);\n};\n\nvar keyCount = 0;\n\nfunction atom(read, write) {\n  var key = \"atom\".concat(++keyCount);\n  var config = {\n    toString: function toString() {\n      return key;\n    }\n  };\n\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n\n    config.read = function (get) {\n      return get(config);\n    };\n\n    config.write = function (get, set, update) {\n      return set(config, typeof update === \"function\" ? update(get(config)) : update);\n    };\n  }\n\n  if (write) {\n    config.write = write;\n  }\n\n  return config;\n}\n\nfunction useAtomValue(atom, scope) {\n  var ScopeContext = getScopeContext(scope);\n  var scopeContainer = useContext(ScopeContext);\n  var store = scopeContainer.s,\n      versionFromProvider = scopeContainer.v;\n\n  var getAtomValue = function getAtomValue(version2) {\n    var atomState = store[READ_ATOM](atom, version2);\n\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n\n    if (\"p\" in atomState) {\n      throw atomState.p;\n    }\n\n    if (\"v\" in atomState) {\n      return atomState.v;\n    }\n\n    throw new Error(\"no atom value\");\n  };\n\n  var _useReducer = useReducer(function (prev, nextVersion) {\n    var nextValue = getAtomValue(nextVersion);\n\n    if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n      return prev;\n    }\n\n    return [nextVersion, nextValue, atom];\n  }, versionFromProvider, function (initialVersion) {\n    var initialValue = getAtomValue(initialVersion);\n    return [initialVersion, initialValue, atom];\n  }),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      _useReducer2$ = _slicedToArray(_useReducer2[0], 3),\n      version = _useReducer2$[0],\n      valueFromReducer = _useReducer2$[1],\n      atomFromReducer = _useReducer2$[2],\n      rerenderIfChanged = _useReducer2[1];\n\n  var value = valueFromReducer;\n\n  if (atomFromReducer !== atom) {\n    rerenderIfChanged(version);\n    value = getAtomValue(version);\n  }\n\n  useEffect(function () {\n    var versionFromProvider2 = scopeContainer.v;\n\n    if (versionFromProvider2) {\n      store[COMMIT_ATOM](atom, versionFromProvider2);\n    }\n\n    var unsubscribe = store[SUBSCRIBE_ATOM](atom, rerenderIfChanged, versionFromProvider2);\n    rerenderIfChanged(versionFromProvider2);\n    return unsubscribe;\n  }, [store, atom, scopeContainer]);\n  useEffect(function () {\n    store[COMMIT_ATOM](atom, version);\n  });\n  useDebugValue(value);\n  return value;\n}\n\nfunction useSetAtom(atom, scope) {\n  var ScopeContext = getScopeContext(scope);\n\n  var _useContext = useContext(ScopeContext),\n      store = _useContext.s,\n      versionedWrite = _useContext.w;\n\n  var setAtom = useCallback(function (update) {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !(\"write\" in atom)) {\n      throw new Error(\"not writable atom\");\n    }\n\n    var write = function write(version) {\n      return store[WRITE_ATOM](atom, update, version);\n    };\n\n    return versionedWrite ? versionedWrite(write) : write();\n  }, [store, versionedWrite, atom]);\n  return setAtom;\n}\n\nfunction useAtom(atom, scope) {\n  if (\"scope\" in atom) {\n    console.warn(\"atom.scope is deprecated. Please do useAtom(atom, scope) instead.\");\n    scope = atom.scope;\n  }\n\n  return [useAtomValue(atom, scope), useSetAtom(atom, scope)];\n}\n\nexport { Provider, getScopeContext as SECRET_INTERNAL_getScopeContext, atom, createStoreForExport as unstable_createStore, useAtom, useAtomValue, useSetAtom };","import React, { forwardRef, PropsWithChildren } from 'react'\nimport { twMerge } from 'tailwind-merge'\n\ntype MainProps = {\n  className?: string\n}\n\nexport const Main = forwardRef<HTMLDivElement, PropsWithChildren<MainProps>>(({ children, className = '' }, ref) => {\n  return (\n    <main className={twMerge('relative overflow-auto', className)} ref={ref}>\n      {children}\n    </main>\n  )\n})\n","import { Atom, Provider } from 'jotai'\nimport React, { forwardRef, ReactNode } from 'react'\n\nimport { Main } from './Main'\n\ntype LayoutProps = {\n  seo?: any\n  fullWidth?: boolean\n  navbar?: ReactNode\n  providerData?: Iterable<readonly [Atom<unknown>, unknown]> | undefined\n  children: ReactNode\n}\n\nconst Layout = forwardRef<HTMLDivElement, LayoutProps>(({ children, navbar, providerData }, ref) => {\n  return (\n    <Provider initialValues={providerData}>\n      <div className=\"grid h-screen bg-primary\" style={{ gridTemplateRows: `auto 1fr` }}>\n        {/* <Seo seo={seo} /> */}\n        {navbar}\n        <Main ref={ref}>{children}</Main>\n      </div>\n    </Provider>\n  )\n})\n\nexport default Layout\n","function notEmpty<TValue>(value: TValue | null | undefined): value is TValue {\n  if (value === null || value === undefined) return false\n  return true\n}\n\nexport default notEmpty\n"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","minLen","_arrayLikeToArray","n","prototype","toString","call","slice","constructor","name","from","test","_unsupportedIterableToArray","F","s","done","value","e","_e","f","TypeError","err","normalCompletion","didErr","step","next","_e2","return","arr","len","arr2","SUSPENSE_PROMISE","isSuspensePromise","promise","cancelSuspensePromise","suspensePromise","_a","_b","c","isEqualSuspensePromise","oldSuspensePromise","newSuspensePromise","oldOriginalPromise","newOriginalPromise","createSuspensePromise","objectToAttach","Promise","resolve","then","hasInitialValue","atom","READ_ATOM","WRITE_ATOM","COMMIT_ATOM","SUBSCRIBE_ATOM","createStore","initialValues","stateListeners","mountedAtoms","committedAtomStateMap","WeakMap","mountedMap","pendingMap","Map","Set","_step","_iterator","_step$value","_atom2","atomState","v","r","d","freeze","console","warn","set","_ref5","suspensePromiseCacheMap","versionedAtomStateMapMap","getVersionedAtomStateMap","version","versionedAtomStateMap","get","getAtomState","_atomState","p","setAtomState","prevAtomState","has","createReadDependencies","prevReadDependencies","undefined","dependencies","readDependencies","changed","revision","size","setAtomValue","nextAtomState","is","every","a","flushPending","setAtomReadError","error","setAtomSuspensePromise","cache","delete","addSuspensePromiseToCache","setAtomPromiseOrValue","promiseOrValue","catch","readAtomState","force","_atomState2","isSuspensePromiseAlreadyCancelled","_","aState","_ref","_ref2","read","add","init","Error","errorOrPromise","readAtom","readingAtom","canUnmountAtom","mounted","l","t","invalidateDependents","dependent","setAtomInvalidated","writeAtomState","update","isSync","promiseOrVoid","write","writeGetter","options","unstable_promise","info","promiseOrVoid2","versionSet","cancelAllSuspensePromiseInCache","cancelledVersion","writeAtom","writingAtom","mountAtom","initialDependent","aMounted","isActuallyWritableAtom","onMount","onUnmount","u","unmountAtom","mountDependencies","listener","pending","clear","_ref3","_ref4","commitAtom","_atom","commitVersionedAtomStateMap","subscribeAtom","callback","addingAtom","addAtom","listeners","deletingAtom","delAtom","restoreAtoms","values","_step2","_iterator2","_step2$value","_atom3","_value","createScopeContainer","unstable_createStore","SECRET_INTERNAL_store","ScopeContextMap","getScopeContext","scope","createContext","Provider","_ref7","children","unstable_enableVersionedWrite","_useState","useState","_useState2","setVersion","useEffect","scopeContainer","scopeContainerRef","current","w","useRef","retrying","parentVersion","nextVersion","fn","ScopeContainerContext","createElement","keyCount","concat","config","useAtomValue","ScopeContext","useContext","store","versionFromProvider","getAtomValue","version2","_useReducer","useReducer","prev","nextValue","initialVersion","_useReducer2","_useReducer2$","valueFromReducer","atomFromReducer","rerenderIfChanged","versionFromProvider2","unsubscribe","useDebugValue","useSetAtom","_useContext","versionedWrite","useCallback","useAtom","Main","forwardRef","ref","className","React","twMerge","navbar","providerData","style","gridTemplateRows"],"sourceRoot":""}